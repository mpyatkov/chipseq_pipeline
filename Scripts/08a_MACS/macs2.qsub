#!/bin/bash -l
set -eu

##################################################################################
#Andy Rampersaud, 03.13.17
#This script is called by macs2.sh
##################################################################################
# Specify which shell to use
#$ -S /bin/bash
#$ -cwd
#$ -j y
#$ -l scratch_free=200G

##################################################################################
#Initialize variables from macs2.sh
##################################################################################
#checking the command line arg
#-ne : "is not equal to"
if [ $# -ne 5 ] ; then
    echo "Need 5 arguments for the qsub command:"
    echo "qsub -N ${Job_Name}'_'${Sample_ID} -P waxmanlab -l h_rt=${TIME_LIMIT} macs2.qsub ${Sample_ID} ${Dataset_DIR} ${Sample_Labels_DIR} ${DHS_DATA} ${SCRIPT_DIR}"
    exit 0
fi
#process the command line arguments
Sample_ID=$1
Dataset_DIR=$2
Sample_Labels_DIR=$3
DHS_DATA=$4
SCRIPT_DIR=$5

#Print variables (make sure they appear correctly):
echo "Start of variable list:"
echo "Sample_ID: ${Sample_ID}"
echo "Dataset_DIR: ${Dataset_DIR}"
echo "Sample_Labels_DIR: ${Sample_Labels_DIR}"
echo "DHS_DATA: ${DHS_DATA}"
echo "SCRIPT_DIR: ${SCRIPT_DIR}"
echo ""

# Now let's keep track of some information just in case anything goes wrong
echo "=========================================================="
#Use to calculate job time:
#Start_Time in seconds
Start_Time=$(date +"%s")
echo "Starting on : $(date)"
echo "Running on node : $(hostname)"
echo "Current directory : $(pwd)"
echo "Current job ID : $JOB_ID"
echo "Current job name : $JOB_NAME"
echo "Task index number : $SGE_TASK_ID"
echo "=========================================================="

# Go to local scratch directory

echo 'Change dir to scratch directory'
cd ${TMPDIR}


################################################################################
echo 'Loading required modules...'
module load boost
module load bedtools/2.27.1
module load python2/2.7.16
module load macs2/2.1.2.1
module load R/3.6.0

################################################################################
#Need to copy input .bam and .bed files
cp "${Dataset_DIR}/${Sample_ID}/fastq/bowtie2/${Sample_ID}_sorted_mapped.bam" .
cp "${Dataset_DIR}/${Sample_ID}/fastq/bowtie2/${Sample_ID}_fragments.bed.gz" .


################################################################################
#Copy peak width scripts to scratch dir
JOB_SCRIPT_DIR=${SCRIPT_DIR}/Job_Scripts
cp $JOB_SCRIPT_DIR/Peak_Width/Peak_Width* . 
#Copy genomeIndex folder for BED -> BAM conversion
cp -r $JOB_SCRIPT_DIR/genomeIndex .
#Copy conversion folder for making bigBed of MACS2 peaks
cp -r $JOB_SCRIPT_DIR/Convert_BED_to_WIG_7/BED_to_WIG .


################################################################################
#ENCODE has a list of blacklisted sites that should be removed:
#https://sites.google.com/site/anshulkundaje/projects/blacklists
cp ${JOB_SCRIPT_DIR}/ENCODE_Blacklist/mm9-blacklist.bed.gz .
gzip -d mm9-blacklist.bed.gz
#Need to copy overlap scripts:
cp ${JOB_SCRIPT_DIR}/Overlap_Script/overlap.* .


################################################################################
OUTPUT_DIR=${Dataset_DIR}/${Sample_ID}/fastq/bowtie2
mkdir -p $OUTPUT_DIR

name=${Sample_ID}

################################################################################
echo 'Starting macs2 command'

#Need an if statement to check DHS_DATA
if [ "${DHS_DATA}" == "NO" ] ;
then
    (set -x; macs2 callpeak -t ${Sample_ID}'_sorted_mapped.bam' -f BAMPE -g mm -n $name'_MACS2_output'/$name'_MACS2' --keep-dup all)
fi

################################################################################
#Need an if statement to check DHS_DATA

tree
mkdir -p "${name}_MACS2_output"

if [ "${DHS_DATA}" == "YES" ] ;
then
    # narrow peaks
    macs2 callpeak -t "${Sample_ID}_sorted_mapped.bam" -f BAMPE -g mm -n "${name}_MACS2_output/${name}_narrow_MACS2" --keep-dup all --nomodel --extsize 200
    tree

    # broad peaks
    macs2 callpeak -t "${Sample_ID}_sorted_mapped.bam" -f BAMPE -g mm -n "${name}_MACS2_output/${name}_broad_MACS2" --keep-dup all --nomodel --extsize 200 --broad
    tree 
fi


################################################################################



echo 'Making BED files of MACS2 output files'

function peak_to_bed() {
    local input=$1
    local output=$2

    awk '{print $1"\t"$2"\t"$3"\t"$4}' $input > temp1.bed

    echo 'Filtering peaks:'
    echo 'Omit chrM'
    echo 'Omit random'
    echo 'Check that end position is greater than start position'
    echo 'Check that start position is greater than zero'
    echo 'Check that end position is greater than zero'

    # awk 'BEGIN {OFS="\t"} {if ($1~/chr/ && $1 !="chrM" && $1 !~/random/ && $3>$2 && $2>0 && $3>0)
    # print $0 > temp2.bed;
    # else 
    # print $0 > Omitted_Peaks.bed}' temp1.bed 

    # awk 'BEGIN {OFS="\t"}
    # {if ($1~/chr/ && $1 !="chrM" && $1 !~/random/ && $3>$2 && $2>0 && $3>0)
    # print $0 > "'$name'_MACS2_output'/temp2.bed'";
    # else 
    # print $0 > "'$name'_MACS2_output'/Omitted_Peaks.bed'"}' $name'_MACS2_output'/temp1.bed 
    
    awk 'BEGIN {OFS="\t"} {if ($1~/chr/ && $1 !="chrM" && $1 !~/random/ && $3>$2 && $2>0 && $3>0) print $0 > "temp2.bed"}' temp1.bed
    
    echo 'Filtering peaks less than 100bp peak width from BED file'

    awk '{if($3-$2>99){print $0}}' temp2.bed > $output

    rm temp1.bed temp2.bed
}

pushd "${name}_MACS2_output"
peak_to_bed "${name}_narrow_MACS2_peaks.narrowPeak" "${name}_narrow_MACS2_peaks.narrowPeak.bed"
peak_to_bed "${name}_broad_MACS2_peaks.broadPeak" "${name}_broad_MACS2_peaks.broadPeak.bed"

echo 'BEFORE ENCODE_Blacklist filter:'
# Count1_Before=$(wc -l < ${name}_narrow_MACS2_peaks.narrowPeak.bed)
# Count2_Before=$(wc -l < ${name}_narrow_MACS2_peaks.narrowPeak)
# Count3_Before=$(wc -l < ${name}_narrow_MACS2_summits.bed)
# Count4_Before=$(wc -l < ${name}_narrow_MACS2_peaks.xls)

cp ../mm9-blacklist.bed ./
cp ../overlap.* ./

echo 'Overlap BED file with mm9-blacklist.bed and filter out overlap'

./overlap.sh "${name}_narrow_MACS2_peaks.narrowPeak.bed" mm9-blacklist.bed
#We want the BED file regions that don't overlap the mm9-blacklist.bed: $name'_MACS2_peaks.narrowPeak''_unique.bed'
#Copy this BED file from the *_Output folder, then rename to replace original BED file
#cp *_Output/$name'_MACS2_peaks.narrowPeak''_unique.bed' ./$name'_MACS2_peaks.narrowPeak.bed'
#Use intersectBed -v:

function apply_blacklist(){
    local file=$1
    local black=$2
    intersectBed -v -a $file -b $black > "$file.filtered"
    mv "$file.filtered" $file
}

apply_blacklist "${name}_narrow_MACS2_peaks.narrowPeak.bed" mm9-blacklist.bed
apply_blacklist "${name}_broad_MACS2_peaks.broadPeak.bed" mm9-blacklist.bed

apply_blacklist "${name}_narrow_MACS2_peaks.narrowPeak" mm9-blacklist.bed
apply_blacklist "${name}_broad_MACS2_peaks.broadPeak" mm9-blacklist.bed

apply_blacklist "${name}_narrow_MACS2_summits.bed" mm9-blacklist.bed

ls -la

## remove blacklist regions from xls files
function apply_blacklist_xls(){
    local xls=$1

    #Need to filter the $name'_MACS2_peaks.xls' file
    #This file has a header section from line 1 to line 19
    #Rather than hard-code the line numbers, better to search for "#" in the first character
    #Use grep command to search for "#" at the start of each line:
    grep '^#' $xls > Header1.txt

    #Want everything after the header section (doesn't match "#" at the start of each line)
    grep -v '^#' $xls > Coordinates1.txt

    #Save 2nd section of header lines:
    head -2 Coordinates1.txt > Header2.txt

    #Get rid of first 2 header lines:
    awk 'FNR > 2' Coordinates1.txt > Coordinates2.txt

    #Filter:
    intersectBed -v -a Coordinates2.txt -b mm9-blacklist.bed > filtered.txt

    #Add header section back on:
    cat Header1.txt Header2.txt filtered.txt > $xls

    # replace -log10(pvalue/qvalue) and -log10(qvalue) to minus_log10_pvalue/qvalue
    sed -i -E 's/-log10\(/minus_log10_/g;s/value\)/value/g' $xls
    
    #Remove temp files:
    rm Header*.txt
    rm Coordinates*.txt
    rm filtered.txt
}

apply_blacklist_xls "${name}_narrow_MACS2_peaks.xls"
apply_blacklist_xls "${name}_broad_MACS2_peaks.xls"

#Remove files from $name'_MACS2_output' folder:
rm mm9-blacklist.bed
rm overlap.*

popd


# echo 'AFTER ENCODE_Blacklist filter:'
# echo 'MACS2_peaks.narrowPeak.bed file line count:'
# Count1_After=$(wc -l < $name'_MACS2_output'/$name'_MACS2_peaks.narrowPeak.bed')
# echo ${Count1_After}
# #Calculate the difference: (Count1_Before - Count1_After)
# Count1_Diff=$(echo "$Count1_Before - $Count1_After" | bc)
# echo 'Number of peaks lost:'
# echo ${Count1_Diff}

# echo 'MACS2_peaks.narrowPeak file line count:'
# Count2_After=$(wc -l < $name'_MACS2_output'/$name'_MACS2_peaks.narrowPeak')
# echo ${Count2_After}
# #Calculate the difference: (Count2_Before - Count2_After)
# Count2_Diff=$(echo "$Count2_Before - $Count2_After" | bc)
# echo 'Number of peaks lost:'
# echo ${Count2_Diff}

# echo 'MACS2_summits.bed file line count:'
# Count3_After=$(wc -l < $name'_MACS2_output'/$name'_MACS2_summits.bed')
# echo ${Count3_After}
# #Calculate the difference: (Count3_Before - Count3_After)
# Count3_Diff=$(echo "$Count3_Before - $Count3_After" | bc)
# echo 'Number of summits lost:'
# echo ${Count3_Diff}

# echo 'MACS2_peaks.xls file line count:'
# Count4_After=$(wc -l < $name'_MACS2_output'/$name'_MACS2_peaks.xls')
# echo ${Count4_After}
# #Calculate the difference: (Count4_Before - Count4_After)
# Count4_Diff=$(echo "$Count4_Before - $Count4_After" | bc)
# echo 'Number of peaks lost:'
# echo ${Count4_Diff}


################################################################################
#Combine MACS peak discovery with calculating the number of reads in these peaks
################################################################################
echo 'Starting coverageBed command'

#######################################################
#Count reads in regular peaks
#######################################################

# coverageBed for properly-paired reads
echo 'Starting coverageBed for properly-paired reads'
coverageBed -a "${name}_MACS2_output/${name}_narrow_MACS2_peaks.narrowPeak.bed" -b "${Sample_ID}_fragments.bed.gz" > "${name}_read_MACS2_peaks.out1"

echo 'Ended coverageBed for properly-paired reads'
cp "${name}_read_MACS2_peaks.out1" "${name}_MACS2_output"


################################################################################
#Combine MACS peak discovery with peak width distribution summary
################################################################################
## TODO: remove this stuff
echo 'Starting Peak_Width.sh'

./Peak_Width.sh "./${name}_MACS2_output/${name}_narrow_MACS2_peaks.narrowPeak.bed"
#Copy output text file to output dir
cp *_Stats.txt "${name}_MACS2_output"

################################################################################
#Combine MACS peak discovery with BED -> BigBed conversion
################################################################################

echo 'Starting BED_to_WIG'
#Copy BED file to conversion folder:
mkdir -p ./BED_to_WIG/Input_files/
mkdir -p ./BED_to_WIG/Input_files_2/

cp "./${name}_MACS2_output/${name}_narrow_MACS2_peaks.narrowPeak.bed" ./BED_to_WIG/Input_files/
cp "./${name}_MACS2_output/${name}_broad_MACS2_peaks.broadPeak.bed" ./BED_to_WIG/Input_files/

pushd BED_to_WIG/
./BED_to_WIG.sh

# ls -ll
# ls -ll temp_bb
mv temp_bb/*.bb "../${name}_MACS2_output"

#cp -rf ../$name'_MACS2_output'/*.bb /net/waxman-server/mnt/data/waxmanlabvm_home/kkarri/tingyac
popd


echo 'Finished BED_to_WIG'
echo 'Copy macs2 output folder to input dir'
########################################################
#Remove output dir from storage (running multiple times)
if [ -d $OUTPUT_DIR/$name'_MACS2_output' ]; then
    rm -r $OUTPUT_DIR/$name'_MACS2_output';
fi
########################################################
cp -r "${name}_MACS2_output" $OUTPUT_DIR
echo "cp -r $name'_MACS2_output' $OUTPUT_DIR"
########################################################

echo
echo "List files in scratch"
echo
ls -alh

echo "=========================================================="
echo "Finished on : $(date)"
#Use to calculate job time:
#End_Time in seconds
End_Time=$(date +"%s")
diff=$(($End_Time-$Start_Time))
echo "$(($diff / 3600)) hours, $((($diff / 60) % 60)) minutes and $(($diff % 60)) seconds elapsed."
echo "=========================================================="
echo "IAMOK"
