#!/bin/bash -l
set -e
##################################################################################
#Andy Rampersaud, 12.14.16
#This script is called by Run_Jobs.sh
##################################################################################
# Specify which shell to use
#$ -S /bin/bash
#$ -cwd
#$ -j y
#Seems like cutadapt/trim_galore automatically uses multiple cores
#If only using 1 core you'll get emails from the SCC process reaper
#You can use option "-pe omp N", where N is the number of cores ( number of course on our system can be any integer between 1 and 16):
#$ -pe omp 8

##################################################################################
#Initialize variables from Run_Jobs.sh
##################################################################################
#checking the command line arg
#-ne : "is not equal to"
if [ $# -ne 5 ] ; then
    echo "Need 5 arguments for the qsub command:"
    echo "qsub -N ${Job_Name}'_'${Sample_ID} -P waxmanlab -l h_rt=${TIME_LIMIT} Trim_Galore.qsub ${Sample_ID} ${Dataset_DIR} ${Sample_Labels_DIR} ${SCRIPT_DIR} ${READ_LEN}"
    exit 0
fi
#process the command line arguments
Sample_ID=$1
Dataset_DIR=$2
Sample_Labels_DIR=$3
SCRIPT_DIR=$4
READ_LEN=$5

#Print variables (make sure they appear correctly):
echo "-----------------------"
echo "Start of variable list:"
echo "-----------------------"
echo "Sample_ID:"
echo ${Sample_ID}
echo "Dataset_DIR:"
echo ${Dataset_DIR}
echo "Sample_Labels_DIR:"
echo ${Sample_Labels_DIR}
echo "SCRIPT_DIR:"
echo ${SCRIPT_DIR}
echo "READ_LEN:"
echo ${READ_LEN}
echo "-----------------------"
echo "End of variable list"
echo "-----------------------"

echo "=========================================================="
#Use to calculate job time:
#Start_Time in seconds
Start_Time=$(date +"%s")
echo "Starting on : $(date)"
echo "Running on node : $(hostname)"
echo "Current directory : $(pwd)"
echo "Current job ID : $JOB_ID"
echo "Current job name : $JOB_NAME"
echo "Task index number : $SGE_TASK_ID"
echo "Parameter for multiple cores : $NSLOTS"
echo "=========================================================="

# Go to local scratch directory
echo 'Change dir to scratch directory'
cd ${TMPDIR}

echo 'Loading required modules...'

module load trimgalore
module load cutadapt
# module load cutadapt/1.18
# module load trimgalore/0.4.4

#module help trim_galore
#----------- Module Specific Help for 'trim_galore/0.4.2' ----------
#trim_galore 0.4.2: A wrapper around Cutadapt and FastQC to consistently apply adapter and quality trimming to FastQ files, with extra functionality for RRBS data.

#Trim Galore! is a wrapper script to automate quality and adapter trimming as well as quality control, with some added functionality to remove biased methylation positions for RRBS sequence files (for directional, non-directional (or paired-end) sequencing). It's main features are:


# - For adapter trimming, Trim Galore! uses the first 13 bp of Illumina standard adapters ('AGATCGGAAGAGC') by default (suitable for both ends of paired-end libraries), but accepts other adapter sequence, too
# - For MspI-digested RRBS libraries, Trim Galore! performs quality and adapter trimming in two subsequent steps. This allows it to remove 2 additional bases that contain a cytosine which was artificially introduced in the end-repair step during the library preparation
# - For any kind of FastQ file other than MspI-digested RRBS, Trim Galore! can perform single-pass adapter- and quality trimming
# - The Phred quality of basecalls and the stringency for adapter removal can be specified individually
# - Trim Galore! can remove sequences if they become too short during the trimming process. For paired-end files Trim Galore! removes entire sequence pairs if one (or both) of the two reads became shorter than the set length cutoff. Reads of a read-pair that are longer than a given threshold but for which the partner read has become too short can optionally be written out to single-end files. This ensures that the information of a read pair is not lost entirely if only one read is of good quality
# - Trim Galore! can trim paired-end files by 1 additional bp from the 3' end of all reads to avoid problems with invalid alignments with Bowtie 1
# - Trim Galore! accepts and produces standard or gzip compressed FastQ files
# - FastQC can be run on the resulting output files once trimming has completed (optional)


#For more information on trim_galore, please see http://www.bioinformatics.babraham.ac.uk/projects/trim_galore/
##################################################################################


# copy user input data files to scratch
cp ${Dataset_DIR}/${Sample_ID}/fastq/*R1*.fastq.gz .
cp ${Dataset_DIR}/${Sample_ID}/fastq/*R2*.fastq.gz .

Left_List=$(find . -name "*R1*.fastq.gz" | xargs -I% basename % | paste -s -d ",")
Right_List=$(find . -name "*R2*.fastq.gz" | xargs -I% basename % | paste -s -d ",")

#Make output dir:
STORAGE_DIR=${Dataset_DIR}/${Sample_ID}/fastq
OUTPUT_DIR=$TMPDIR/trim_galore_output

mkdir -p $OUTPUT_DIR
#Remove output dir from storage (running multiple times)
rm -rf ${STORAGE_DIR}/trim_galore_output

echo 'List files in the scratch directory:'

ls -alh

echo 'Starting to run my commands'

# run my commands.

# (set -x; trim_galore --quality 0 --stringency 13 --length ${READ_LEN} --paired ${Left_List} ${Right_List} --output_dir ${OUTPUT_DIR}) ## PREVIOUS

(set -x; trim_galore --quality 0 --stringency 13 --fastqc --length ${READ_LEN} --paired ${Left_List} ${Right_List} --output_dir ${OUTPUT_DIR} --cores $NSLOTS) ## PREVIOUS

pushd ${OUTPUT_DIR}
## rename extensions to make it consistent with the downstream pipeline
rename ".fq.gz" ".fastq.gz" *.fq.gz
popd

echo 'Finished trim_galore command'

ls -l ${OUTPUT_DIR}

#Even with omitting the (--keep) option, still need to remove the FASTQ file:
# set +e
# rm ${OUTPUT_DIR}/*.fastq.gz
# set -e

echo 'Copy OUTPUT_DIR file to storage'
cp -a ${OUTPUT_DIR} ${STORAGE_DIR}

echo "List files in scratch"
ls -alh

cd ${OUTPUT_DIR}

echo "List files in OUTPUT_DIR"
ls -alh

echo "=========================================================="
echo "Finished on : $(date)"
#Use to calculate job time:
#End_Time in seconds
End_Time=$(date +"%s")
diff=$(($End_Time-$Start_Time))
echo "$(($diff / 3600)) hours, $((($diff / 60) % 60)) minutes and $(($diff % 60)) seconds elapsed."
echo "=========================================================="
echo "IAMOK"
