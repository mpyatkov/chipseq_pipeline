#!/bin/bash -l
set -e
##################################################################################
#Andy Rampersaud, 12.14.16
#This script is called by Run_Jobs.sh
##################################################################################
# Specify which shell to use
#$ -S /bin/bash
# Run on the current working directory
#$ -cwd

# Join standard output and error to a single file  
#$ -j y
# change to y if you want a single qlog file 

##################################################################################
#Initialize variables from Run_Jobs.sh
##################################################################################
#checking the command line arg
#-ne : "is not equal to"
if [ $# -ne 5 ] ; then
    echo "Need 5 arguments for the qsub command:"
    echo "qsub -N ${Job_Name}'_'${Sample_ID} -P waxmanlab -l h_rt=${TIME_LIMIT} Trim_Galore.qsub ${Sample_ID} ${Dataset_DIR} ${Sample_Labels_DIR} ${SCRIPT_DIR} ${READ_LEN}"
    exit 0
fi
#process the command line arguments
Sample_ID=$1
Dataset_DIR=$2
Sample_Labels_DIR=$3
SCRIPT_DIR=$4
READ_LEN=$5

#http://www.ibm.com/developerworks/library/l-bash-parameters/
#Note: If you have more than 9 parameters, you cannot use $10 to refer to the tenth one. You must first either process or save the first parameter ($1), then use the shift command to drop parameter 1 and move all remaining parameters down 1, so that $10 becomes $9 and so on.

#http://unix.stackexchange.com/questions/104420/how-to-use-command-line-arguments-in-a-shell-script
#If you need access more than 9 command line arguments, you can use the shift command. Example: shift 2 renames $3 to $1, $4 to $2 etc.

#Print variables (make sure they appear correctly):
echo "-----------------------"
echo "Start of variable list:"
echo "-----------------------"
echo "Sample_ID:"
echo ${Sample_ID}
echo "Dataset_DIR:"
echo ${Dataset_DIR}
echo "Sample_Labels_DIR:"
echo ${Sample_Labels_DIR}
echo "SCRIPT_DIR:"
echo ${SCRIPT_DIR}
echo "READ_LEN:"
echo ${READ_LEN}
echo "-----------------------"
echo "End of variable list"
echo "-----------------------"

#Seems like cutadapt/trim_galore automatically uses multiple cores
#If only using 1 core you'll get emails from the SCC process reaper
#You can use option "-pe omp N", where N is the number of cores ( number of course on our system can be any integer between 1 and 16):
#$ -pe omp 8

# Now let's keep track of some information just in case anything goes wrong
echo "=========================================================="
#Use to calculate job time:
#Start_Time in seconds
Start_Time=$(date +"%s")
echo "Starting on : $(date)"
echo "Running on node : $(hostname)"
echo "Current directory : $(pwd)"
echo "Current job ID : $JOB_ID"
echo "Current job name : $JOB_NAME"
echo "Task index number : $SGE_TASK_ID"
echo "Parameter for multiple cores : $NSLOTS"
echo "=========================================================="

# Go to local scratch directory
echo
echo 'Change dir to scratch directory'
echo
cd ${TMPDIR}
echo
echo 'Print scratch directory location:'
echo
echo $TMPDIR
#--------------------------------------
echo
echo 'Loading required modules...'
echo
#Make sure the shebang line = #!/bin/bash -l
set -e
#Need the -l option to load modules
#Search for latest program installed:
#module avail -t 2>&1 | grep -i trim
#Directly calling executable
#Still need to call:
#cutadapt
#module load python2/2.7.16
#Charles A Jahnke was able to install trim_galore on the SCC:
module load cutadapt/1.18
module load fastqc
module load trimgalore/0.4.4
##################################################################################
#module help python
#----------- Module Specific Help for 'python/2.7.11' --------------
#python 2.7.11 A general purpose, interpretive programming language.
#For more information on python, please see
#* Our help page: http://www.bu.edu/tech/support/research/software-and-programming/common-languages/python/
#* Our tutorial page: http://www.bu.edu/tech/support/research/training-consulting/live-tutorials/#PROGRAMMING
#* The vendor's website: http://www.python.org
#For more information on python, please see https://www.python.org
#-----------------------------------------------------
#module help fastqc
#----------- Module Specific Help for 'fastqc/0.11.5' --------------
#fastqc 0.11.5: A quality control tool for high throughput sequence data.
#FastQC aims to provide a simple way to do some quality control checks on raw sequence data coming from high throughput sequencing pipelines. It provides a modular set of analyses which you can use to give a quick impression of whether your data has any problems of which you should be aware before doing any further analysis.
#For more information on fastqc, please see http://www.bioinformatics.babraham.ac.uk/projects/fastqc
#-----------------------------------------------------
#module help trim_galore
#----------- Module Specific Help for 'trim_galore/0.4.2' ----------
#trim_galore 0.4.2: A wrapper around Cutadapt and FastQC to consistently apply adapter and quality trimming to FastQ files, with extra functionality for RRBS data.

#Trim Galore! is a wrapper script to automate quality and adapter trimming as well as quality control, with some added functionality to remove biased methylation positions for RRBS sequence files (for directional, non-directional (or paired-end) sequencing). It's main features are:


# - For adapter trimming, Trim Galore! uses the first 13 bp of Illumina standard adapters ('AGATCGGAAGAGC') by default (suitable for both ends of paired-end libraries), but accepts other adapter sequence, too
# - For MspI-digested RRBS libraries, Trim Galore! performs quality and adapter trimming in two subsequent steps. This allows it to remove 2 additional bases that contain a cytosine which was artificially introduced in the end-repair step during the library preparation
# - For any kind of FastQ file other than MspI-digested RRBS, Trim Galore! can perform single-pass adapter- and quality trimming
# - The Phred quality of basecalls and the stringency for adapter removal can be specified individually
# - Trim Galore! can remove sequences if they become too short during the trimming process. For paired-end files Trim Galore! removes entire sequence pairs if one (or both) of the two reads became shorter than the set length cutoff. Reads of a read-pair that are longer than a given threshold but for which the partner read has become too short can optionally be written out to single-end files. This ensures that the information of a read pair is not lost entirely if only one read is of good quality
# - Trim Galore! can trim paired-end files by 1 additional bp from the 3' end of all reads to avoid problems with invalid alignments with Bowtie 1
# - Trim Galore! accepts and produces standard or gzip compressed FastQ files
# - FastQC can be run on the resulting output files once trimming has completed (optional)


#For more information on trim_galore, please see http://www.bioinformatics.babraham.ac.uk/projects/trim_galore/
##################################################################################

#-----------------------------------------------------
# copy user input data files to scratch
#Copy over the *R1*.fastq.gz file(s):
cp ${Dataset_DIR}/${Sample_ID}/fastq/*R1*.fastq.gz .
#Copy over the *R2*.fastq.gz file(s):
cp ${Dataset_DIR}/${Sample_ID}/fastq/*R2*.fastq.gz .
#-----------------------------------------------------

#We need a comma separated list for the *_1 ("left") set of files:
READ1_FILE_NAME=*R1*.fastq.gz	
for i in ${READ1_FILE_NAME}; 
do
    READ1=`echo $READ1$i,`; 
done
Left_List=${READ1%?}
echo
echo "Here is the Left_List:"
echo ${Left_List}
echo
#-----------------------------------------------------
#We need a comma separated list for the **_2 ("right") set of files:
READ2_FILE_NAME=*R2*.fastq.gz	
for i in ${READ2_FILE_NAME}; 
do
    READ2=`echo $READ2$i,`; 
done
Right_List=${READ2%?}
echo
echo "Here is the Right_List:"
echo ${Right_List}
echo
#-----------------------------------------------------
#Make output dir:
STORAGE_DIR=${Dataset_DIR}/${Sample_ID}/fastq
OUTPUT_DIR=$TMPDIR/trim_galore_output
##############################
if [[ ! -d $OUTPUT_DIR ]]; 
then
    mkdir $OUTPUT_DIR
fi
##############################
########################################################
#Remove output dir from storage (running multiple times)
if [ -d ${STORAGE_DIR}/trim_galore_output ]; 
then
    rm -r ${STORAGE_DIR}/trim_galore_output
fi
########################################################
echo
echo 'List files in the scratch directory:'
echo

ls -alh

echo
echo 'Starting to run my commands'
echo

#echo
#echo 'Unzip files:'
#echo

#time gzip -d *.gz

#echo
#echo 'Finished unzipping'
#echo

# run my commands.
echo
echo 'Starting trim_galore'
echo
#trim_galore is a wrapper for cutadapt:
#http://www.bioinformatics.babraham.ac.uk/projects/trim_galore/
##################################################################################
#cutadapt --help
#---------------------------------------------------------------------------------
#Useful suggestion for removing reads with adaptor sequences:
#https://www.biostars.org/p/68396/
#Could run trim_galore with the length option equal to the read length
#This way any reads with adaptor sequence will be trimmed to some length less than the original read length, in which case, reads shorter than the original read length will be filtered out
#Based on the above I should use the read length (50bp) for the length option
#---------------------------------------------------------------------------------
#--stringency <INT>
#Information about this option:
#http://www.bioinformatics.babraham.ac.uk/projects/trim_galore/trim_galore_User_Guide_v0.3.7.pdf
#Since we know the adaptor to be trimmed:
#Trim Galore identified the same adaptor sequence (AGATCGGAAGAGC)
#The stringency should be the length of the adaptor sequence: 13
#---------------------------------------------------------------------------------
#--quality <INT>
#Don't want to trim based on quality score:
#--quality 0
#---------------------------------------------------------------------------------
#By default, it makes sense to not keep the FASTQ file
#Do not use the (--keep) option
#However, if the user needs to have the FASTQ file, then use the (--keep) option
#---------------------------------------------------------------------------------
#Print the command:
echo "trim_galore --quality 0 --stringency 13 --length ${READ_LEN} --paired ${Left_List} ${Right_List} --output_dir ${OUTPUT_DIR}"
#Run the command:
trim_galore --quality 0 --stringency 13 --length ${READ_LEN} --paired ${Left_List} ${Right_List} --output_dir ${OUTPUT_DIR}
#---------------------------------------------------------------------------------
echo
echo 'Finished trim_galore command'
echo

ls -l ${OUTPUT_DIR}
#Even with omitting the (--keep) option, still need to remove the FASTQ file:
set +e
rm ${OUTPUT_DIR}/*.fastq.gz
set -e

echo
echo 'Copy OUTPUT_DIR file to storage'
echo
cp -r ${OUTPUT_DIR} ${STORAGE_DIR}

echo
echo "List files in scratch"
echo
ls -alh

cd ${OUTPUT_DIR}

echo
echo "List files in OUTPUT_DIR"
echo
ls -alh

echo "=========================================================="
echo "Finished on : $(date)"
#Use to calculate job time:
#End_Time in seconds
End_Time=$(date +"%s")
diff=$(($End_Time-$Start_Time))
echo "$(($diff / 3600)) hours, $((($diff / 60) % 60)) minutes and $(($diff % 60)) seconds elapsed."
echo "=========================================================="
echo "IAMOK"
